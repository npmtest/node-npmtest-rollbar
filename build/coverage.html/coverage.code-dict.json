{"/home/travis/build/npmtest/node-npmtest-rollbar/test.js":"/* istanbul instrument in package npmtest_rollbar */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-rollbar/lib.npmtest_rollbar.js":"/* istanbul instrument in package npmtest_rollbar */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_rollbar = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_rollbar = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-rollbar/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-rollbar && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_rollbar */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_rollbar\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_rollbar.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_rollbar.rollup.js'] =\n            local.assetsDict['/assets.npmtest_rollbar.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_rollbar.__dirname + '/lib.npmtest_rollbar.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-rollbar/node_modules/rollbar/rollbar.js":"/*jslint devel: true, nomen: true, indent: 2, maxlen: 100 */\n\n\"use strict\";\n\nvar logger = require('./lib/logger');\nvar api = require('./lib/api');\nvar notifier = require('./lib/notifier');\nvar parser = require('./lib/parser');\nvar RollbarError = require('./lib/error');\n\nvar initialized = false;\n\n/**\n *\n * Rollbar:\n *\n *  Handle caught and uncaught exceptions, and report messages back to rollbar.\n *\n *  This library requires an account at http://rollbar.com/.\n *\n * Example usage:\n *\n *  Express -\n *\n *     var express = require('express');\n *     var rollbar = require('rollbar');\n *\n *     var app = express();\n *\n *     app.get('/', function (req, res) {\n *       ...\n *     });\n *\n *     // Use the rollbar error handler to send exceptions to your rollbar account\n *     app.use(rollbar.errorHandler('ROLLBAR_ACCESS_TOKEN'));\n *\n *     app.listen(6943);\n *\n *  Standalone -\n *\n *     var rollbar = require('rollbar');\n *     rollbar.init('ROLLBAR_ACCESS_TOKEN');\n *     rollbar.reportMessage('Hello world', 'debug');\n *\n *  Uncaught exceptions -\n *\n *     var rollbar = require('rollbar');\n *     rollbar.handleUncaughtExceptions('ROLLBAR_ACCESS_TOKEN');\n *\n *  Send exceptions and request data -\n *\n *     app.get('/', function (req, res) {\n *       try {\n *         ...\n *       } catch (e) {\n *         rollbar.handleError(e, req);\n *       }\n *     });\n *\n *  Track people -\n *\n *     app.get('/', function (req, res) {\n *       req.userId = 12345; // or req.user_id\n *       rollbar.reportMessage('Interesting event', req);\n *     });\n */\n\nexports.init = function (accessToken, options) {\n  /*\n   * Initialize the rollbar library.\n   *\n   * For more information on each option, see http://rollbar.com/docs/api_items/\n   *\n   * Supported options, (all optional):\n   *\n   *  host - Default: os.hostname() - the hostname of the server the node.js process is running on\n   *  environment - Default: 'unspecified' - the environment the code is running in. e.g. 'staging'\n   *  endpoint - Default: 'https://api.rollbar.com/api/1/' - the url to send items to\n   *  root - the path to your code, (not including any trailing slash) which will be used to link\n   *    source files on rollbar\n   *  branch - the branch in your version control system for this code\n   *  codeVersion - the version or revision of your code\n   *  enabled - Default: true - determines if errors gets reported to Rollbar\n   *\n   */\n  if (!initialized) {\n    options = options || {};\n    if (!accessToken && options.enabled !== false) {\n      logger.error('Missing access_token.');\n      return;\n    }\n\n    options.environment = options.environment || process.env.NODE_ENV || 'unspecified';\n\n    api.init(accessToken, options);\n    notifier.init(api, options);\n    initialized = true;\n  }\n};\n\n\n/*\n * reportMessage(message, level, request, callback)\n *\n * Sends a message to rollbar with optional level, request and callback.\n * The callback should take a single parameter to indicate if there was an\n * error.\n *\n * Parameters:\n *  message - a string to send to rollbar\n *  level - Default: 'error' - optional level, 'debug', 'info', 'warning', 'error', 'critical'\n *  request - optional request object to send along with the message\n *  callback - optional callback that will be invoked once the message was reported.\n *    callback should take 3 parameters: callback(err, payloadData, response)\n *\n * Examples:\n *\n *  rollbar.reportMessage(\"User purchased something awesome!\", \"info\");\n *\n *  rollbar.reportMessage(\"Something suspicious...\", \"debug\", null, function (err, payloadData) {\n *    if (err) {\n *      console.error('Error sending to Rollbar:', err);\n *    } else {\n *      console.log('Reported message to rollbar:');\n *      console.log(payloadData);\n *    }\n *  });\n *\n */\nexports.reportMessage = notifier.reportMessage;\n\n\n/*\n * reportMessageWithPayloadData(message, payloadData, request, callback)\n *\n * The same as reportMessage() but allows you to specify extra data along with the message.\n *\n * Parameters:\n *  message - a string to send to rollbar\n *  payloadData - an object containing key/values to be sent along with the message.\n *    e.g. {level: \"warning\", fingerprint: \"CustomerFingerPrint\"}\n *  request - optional request object to send along with the message\n *  callback - optional callback that will be invoked once the message has been sent to Rollbar.\n *    callback should take 3 parameters: callback(err, payloadData, response)\n *\n * Examples:\n *\n *  rollbar.reportMessageWithPayloadData(\"Memcache miss\",\n *    {level: \"debug\", fingerprint: \"Memcache-miss\"}, null, function (err) {\n *    // message was queued/sent to rollbar\n *  });\n *\n */\nexports.reportMessageWithPayloadData = notifier.reportMessageWithPayloadData;\n\n/*\n * handleError(err, request, callback)\n *\n * Send a details about the error to rollbar along with optional request information.\n *\n * Parameters:\n *  err - an Exception/Error instance\n *  request - an optional request object to send along with the error\n *  callback - optional callback that will be invoked after the error was sent to Rollbar.\n *    callback should take 3 parameters: callback(err, payloadData, response)\n *\n * Examples:\n *\n *  rollbar.handleError(new Error(\"Could not connect to the database\"));\n *\n *  rollbar.handleError(new Error(\"it's just foobar...\"), function (err) {\n *    // error was queued/sent to rollbar\n *  });\n *\n *  rollbar.handleError(new Error(\"invalid request!\"), req);\n *\n */\nexports.handleError = notifier.handleError;\n\n/*\n * handleErrorWithPayloadData(err, payloadData, request, callback)\n *\n * The same as handleError() but allows you to specify additional data to log along with the error,\n * as well as other payload options.\n *\n * Parameters:\n *  err - an Exception/Error instance\n *  payloadData - an object containing keys/values to be sent along with the error report.\n *    e.g. {level: \"warning\"}\n *  request - optional request object to send along with the message\n *  callback - optional callback that will be invoked after the error was sent to Rollbar.\n *    callback should take 3 parameters: callback(err, payloadData, response)\n *\n *  Examples:\n *\n *   rollbar.handleError(new Error(\"Could not connect to database\"), {level: \"warning\"});\n *   rollbar.handleError(new Error(\"Could not connect to database\"),\n *    {custom: {someKey: \"its value, otherKey: [\"other\", \"value\"]}});\n *   rollbar.handleError(new Error(\"error message\"), {}, req, function (err) {\n *     // error was queued/sent to rollbar\n *   });\n */\nexports.handleErrorWithPayloadData = notifier.handleErrorWithPayloadData;\n\n\nexports.errorHandler = function (accessToken, options) {\n  /*\n   * A middleware handler for connect and express.js apps. For a list\n   * of supported options, see the init() docs above.\n   *\n   * All exceptions thrown from inside an express or connect get/post/etc... handler\n   * will be sent to rollbar when this middleware is installed.\n   */\n  exports.init(accessToken, options);\n  return function (err, req, res, next) {\n    var cb = function (rollbarErr) {\n      if (rollbarErr) {\n        logger.error('Error reporting to rollbar, ignoring: ' + rollbarErr);\n      }\n      return next(err, req, res);\n    };\n\n    if (!err) {\n      return next(err, req, res);\n    }\n\n    if (err instanceof Error) {\n      return notifier.handleError(err, req, cb);\n    }\n\n    return notifier.reportMessage('Error: ' + err, 'error', req, cb);\n  };\n};\n\nexports.handleUncaughtExceptionsAndRejections = function (accessToken, options) {\n  exports.handleUncaughtExceptions(accessToken, options);\n  exports.handleUnhandledRejections(accessToken, options);\n};\n\nexports.handleUncaughtExceptions = function (accessToken, options) {\n  /*\n   * Registers a handler for the process.uncaughtException event\n   *\n   * If options.exitOnUncaughtException is set to true, the notifier will\n   * immediately send the uncaught exception + all queued items to rollbar,\n   * then call process.exit(1).\n   *\n   * Note: The node.js authors advise against using these type of handlers.\n   * More info: http://nodejs.org/api/process.html#process_event_uncaughtexception\n   *\n   */\n\n  // Default to not exiting on uncaught exceptions unless options.exitOnUncaughtException is set.\n  options = options || {};\n  var exitOnUncaught = options.exitOnUncaughtException === undefined ?\n        false : !!options.exitOnUncaughtException;\n  delete options.exitOnUncaughtException;\n\n  exports.init(accessToken, options);\n\n  if (initialized) {\n    process.on('uncaughtException', function (err) {\n      logger.error('Handling uncaught exception.');\n      logger.error(err);\n\n      notifier.handleError(err, function (err) {\n        if (err) {\n          logger.error('Encountered an error while handling an uncaught exception.');\n          logger.error(err);\n        }\n\n        if (exitOnUncaught) {\n          process.exit(1);\n        }\n      });\n    });\n  } else {\n    logger.error('Rollbar is not initialized. Uncaught exceptions will not be tracked.');\n  }\n};\n\nexports.handleUnhandledRejections = function (accessToken, options) {\n  /*\n   * Registers a handler for the process.unhandledRejection event.\n   */\n\n  options = options || {};\n\n  exports.init(accessToken, options);\n\n  if (initialized) {\n    process.on('unhandledRejection', function (reason) {\n      logger.error('Handling unhandled rejection.');\n      logger.error(reason);\n\n      notifier.handleError(reason, function (err) {\n        if (err) {\n          logger.error('Encountered an error while handling an unhandled rejection.');\n          logger.error(err);\n        }\n      })\n    });\n  } else {\n    logger.error('Rollbar is not initialized. Uncaught rejections will not be tracked.');\n  }\n};\n\nexports.wait = notifier.wait;\n\nexports.api = api;\nexports.notifier = notifier;\nexports.parser = parser;\nexports.Error = RollbarError;\n","/home/travis/build/npmtest/node-npmtest-rollbar/node_modules/rollbar/lib/logger.js":"/*jslint devel: true, nomen: true, plusplus: true, regexp: true, indent: 2, maxlen: 100 */\n\n\"use strict\";\n\nvar debug = require('debug');\nvar name = 'Rollbar';\n\nvar logger = {\n  log: debug(name + ':log'),\n  error: debug(name + ':error')\n};\n\n// Make logger.log log to stdout rather than stderr\nlogger.log.log = console.log.bind(console);\n\nmodule.exports = logger;\n","/home/travis/build/npmtest/node-npmtest-rollbar/node_modules/rollbar/lib/api.js":"/*jslint devel: true, nomen: true, plusplus: true, regexp: true, indent: 2, maxlen: 100 */\n\n\"use strict\";\n\nvar logger = require('./logger');\nvar async = require('async');\nvar url = require('url');\nvar http = require('http');\nvar https = require('https');\nvar stringify = require('json-stringify-safe');\n\nexports.VERSION = '1';\nexports.endpoint = 'https://api.rollbar.com/api/' + exports.VERSION + '/';\nexports.accessToken = null;\n\nvar RETRIABLE_ERRORS = ['ECONNRESET', 'ENOTFOUND', 'ESOCKETTIMEDOUT', 'ETIMEDOUT', 'ECONNREFUSED', 'EHOSTUNREACH', 'EPIPE', 'EAI_AGAIN'];\n\nvar SETTINGS = {\n  accessToken: null,\n  protocol: 'https',\n  endpoint: exports.endpoint,\n  proxy: null,\n  retryInterval: null\n};\n\nvar retryQueue = [];\nvar retryHandle = null;\n\n\n/*\n * Internal\n */\n\n\nfunction transportOpts(path, method) {\n  var port;\n  port = SETTINGS.port ||\n      (SETTINGS.protocol === 'http' ? 80 : (SETTINGS.protocol === 'https' ? 443 : undefined));\n\n  return {\n    host: SETTINGS.endpointOpts.host,\n    port: port,\n    path: SETTINGS.endpointOpts.path + path,\n    method: method\n  };\n}\n\n\nfunction parseApiResponse(respData, callback) {\n  try {\n    respData = JSON.parse(respData);\n  } catch (e) {\n    logger.error('Could not parse api response, err: ' + e);\n    return callback(e);\n  }\n\n  if (respData.err) {\n    logger.error('Received error: ' + respData.message);\n    return callback(new Error('Api error: ' + (respData.message || 'Unknown error')));\n  }\n\n\n  if (respData.result && respData.result.uuid) {\n    logger.log([\n      'Successful api response.',\n      ' Link: https://rollbar.com/occurrence/uuid/?uuid=' + respData.result.uuid\n    ].join(''));\n\n  } else {\n    logger.log('Successful api response');\n  }\n\n  callback(null, respData.result);\n}\n\nfunction retryApiRequest(args) {\n  if (!SETTINGS.retryInterval)\n    return;\n\n  retryQueue.push(args);\n\n  if (!retryHandle) {\n    retryHandle = setInterval(function() {\n      while (retryQueue.length) {\n        makeApiRequest(retryQueue.shift());\n      }\n    }, SETTINGS.retryInterval);\n  }\n}\n\nfunction makeApiRequest(args) {\n  var writeData, req;\n  var transport = args.transport;\n  var opts = args.opts;\n  var payload = args.payload;\n  var callback = args.callback;\n\n  if (!payload) {\n    return callback(new Error('Cannot send empty request'));\n  }\n\n  try {\n    try {\n      writeData = JSON.stringify(payload);\n    } catch (e) {\n      logger.error('Could not serialize to JSON - falling back to safe-stringify');\n      writeData = stringify(payload);\n    }\n  } catch (e) {\n    logger.error('Could not safe-stringify data. Giving up');\n    return callback(e);\n  }\n\n  opts.headers = opts.headers || {};\n\n  opts.headers['Content-Type'] = 'application/json';\n  opts.headers['Content-Length'] = Buffer.byteLength(writeData, 'utf8');\n  opts.headers['X-Rollbar-Access-Token'] = exports.accessToken;\n\n  if (SETTINGS.proxy) {\n    opts.path = SETTINGS.protocol + '://' + opts.host + opts.path;\n    opts.host = SETTINGS.proxy.host;\n    opts.port = SETTINGS.proxy.port;\n    transport = http;\n  }\n\n  req = transport.request(opts, function (resp) {\n    var respData = [];\n\n    resp.setEncoding('utf8');\n    resp.on('data', function (chunk) {\n      respData.push(chunk);\n    });\n\n    resp.on('end', function () {\n      respData = respData.join('');\n      parseApiResponse(respData, callback);\n    });\n  });\n\n  req.on('error', function (err) {\n    // If the request to Rollbar failed due to a connection error, lets queue\n    // up the requests and try again periodically in the hopes that the connection\n    // will be restored.\n    //\n    // If no retryInterval set, interpret that as not wanting to retry send errors,\n    // so just bail out silently.\n\n    var shouldRetry = false;\n    if (SETTINGS.retryInterval) {\n      for (var i=0, j=RETRIABLE_ERRORS.length; i < j; i++) {\n        if (err.code === RETRIABLE_ERRORS[i]) {\n          shouldRetry = true;\n          break;\n        }\n      }\n    }\n    if (shouldRetry) {\n      retryApiRequest(args);\n    } else {\n      logger.error('Could not make request to rollbar, ' + err);\n      callback(err);\n    }\n  });\n\n  if (writeData) {\n    req.write(writeData);\n  }\n  req.end();\n}\n\n\nfunction postApi(path, payload, callback) {\n  var transport, opts;\n\n  transport = SETTINGS.transport;\n  opts = transportOpts(path, 'POST');\n\n  return makeApiRequest({\n    transport: transport,\n    opts: opts,\n    payload: payload,\n    callback: callback\n  });\n}\n\n\nfunction buildPayload(data) {\n  var payload;\n\n  // The API does not allow a context to be an object.  We need to detect if an\n  // object context is provided.  If so, serialize it.\n  if (typeof data.context == 'object') {\n    try {\n      data.context = JSON.stringify(data.context);\n    } catch (e) {\n      data.context = stringify(data.context);\n    }\n    if (data.context.length > 255) {\n      data.context = data.context.substr(0, 255);\n    }\n  }\n\n  payload = {\n    access_token: exports.accessToken,\n    data: data\n  };\n\n  return payload;\n}\n\n\n/*\n * Public API\n */\n\n\nexports.init = function (accessToken, options) {\n  var opt, portCheck;\n\n  options = options || {};\n  exports.accessToken = accessToken;\n  exports.endpoint = options.endpoint || exports.endpoint;\n\n  for (opt in options) {\n    if (options.hasOwnProperty(opt)) {\n      SETTINGS[opt] = options[opt];\n    }\n  }\n\n  SETTINGS.endpointOpts = url.parse(exports.endpoint);\n  SETTINGS.protocol = SETTINGS.endpointOpts.protocol.split(':')[0];\n  SETTINGS.transport = {http: http, https: https}[SETTINGS.protocol];\n  SETTINGS.proxy = options.proxy;\n\n  portCheck = SETTINGS.endpointOpts.host.split(':');\n  if (portCheck.length > 1) {\n    SETTINGS.endpointOpts.host = portCheck[0];\n    SETTINGS.port = parseInt(portCheck[1], 10);\n  }\n};\n\n\nexports.postItem = function (item, callback) {\n  return postApi('item/', buildPayload(item), callback);\n};","/home/travis/build/npmtest/node-npmtest-rollbar/node_modules/rollbar/lib/notifier.js":"/*jslint devel: true, nomen: true, plusplus: true, regexp: true, indent: 2, maxlen: 100 */\n\n\"use strict\";\n\nvar logger = require('./logger');\nvar async = require('async');\nvar http = require('http');\nvar https = require('https');\nvar uuidV4 = require('uuid').v4;\nvar os = require('os');\nvar url = require('url');\nvar requestIp = require('request-ip');\n\nvar parser = require('./parser');\nvar packageJson = require('../package.json');\nvar stringify = require('json-stringify-safe');\n\n\nexports.VERSION = packageJson.version;\n\n\nvar SETTINGS = {\n  accessToken: null,\n  codeVersion: null,\n  host: os.hostname(),\n  environment: 'development',\n  framework: 'node-js',\n  root: null,  // root path to your code\n  branch: null,  // git branch name\n  showReportedMessageTraces: false, // optionally shows manually-reported errors and a stack trace\n  notifier: {\n    name: 'node_rollbar',\n    version: exports.VERSION\n  },\n  scrubHeaders: ['authorization', 'www-authorization', 'http_authorization', 'omniauth.auth',\n                 'cookie', 'oauth-access-token', 'x_csrf_token', 'http_x_csrf_token', 'x-csrf-token'],\n  scrubFields: ['passwd', 'password', 'password_confirmation', 'secret', 'confirm_password',\n                'password_confirmation', 'secret_token', 'api_key', 'access_token', 'authenticity_token',\n                'oauth_token', 'token', 'user_session_secret', 'request.session.csrf',\n                'request.session._csrf', 'request.params._csrf', 'request.cookie', 'request.cookies'],\n  addRequestData: null,  // Can be set by the user or will default to addRequestData defined below\n  minimumLevel: 'debug',\n  enabled: true\n};\n\n\nvar apiClient;\nvar initialized = false;\nvar pendingItems = [];\nvar waitCallback = null;\n\n/** Internal **/\n\n\nfunction genUuid() {\n  var buf = new Buffer(16);\n  uuidV4(null, buf);\n  return buf.toString('hex');\n}\n\n\nfunction buildBaseData(extra) {\n  var data, props;\n\n  extra = extra || {};\n  data = {\n    timestamp: Math.floor((new Date().getTime()) / 1000),\n    environment: extra.environment || SETTINGS.environment,\n    level: extra.level || 'error',\n    language: 'javascript',\n    framework: extra.framework || SETTINGS.framework,\n    uuid: genUuid(),\n    notifier: JSON.parse(JSON.stringify(SETTINGS.notifier))\n  };\n\n  if (SETTINGS.codeVersion) {\n    data.code_version = SETTINGS.codeVersion;\n  }\n\n  props = Object.getOwnPropertyNames(extra);\n  props.forEach(function (name) {\n    if (!data.hasOwnProperty(name)) {\n      data[name] = extra[name];\n    }\n  });\n\n  data.server = {\n    host: SETTINGS.host,\n    argv: process.argv.concat(),\n    pid: process.pid\n  };\n\n  data.server.host = SETTINGS.host;\n\n  if (SETTINGS.branch) {\n    data.server.branch = SETTINGS.branch;\n  }\n  if (SETTINGS.root) {\n    data.server.root = SETTINGS.root;\n  }\n\n  return data;\n}\n\n\nfunction buildErrorData(baseData, err, callback) {\n  var errors = [];\n  var chain = [];\n\n  do {\n    errors.push(err);\n  } while((err = err.nested) !== undefined);\n\n  baseData.body.trace_chain = chain;\n\n  var cb = function(err) {\n    if(err) {\n      return callback(err);\n    }\n\n    return callback(null);\n  };\n\n  async.eachSeries(errors, _buildTraceData(chain), cb);\n}\n\nfunction _buildTraceData(chain) {\n  return function(ex, cb) {\n    parser.parseException(ex, function (err, errData) {\n      if (err) {\n        return cb(err);\n      }\n\n      chain.push({\n        frames: errData.frames,\n        exception: {\n          class: errData['class'],\n          message: errData.message\n        }\n      });\n\n      return cb();\n    });\n  };\n};\n\n\nfunction charFill(char, num) {\n  var a, x;\n\n  a = [];\n  x = num;\n  while (x > 0) {\n    a[x] = '';\n    x -= 1;\n  }\n  return a.join(char);\n}\n\n\nfunction scrubRequestHeaders(headers, settings) {\n  var obj, k;\n\n  obj = {};\n  settings = settings || SETTINGS;\n  for (k in headers) {\n    if (headers.hasOwnProperty(k)) {\n      if (settings.scrubHeaders.indexOf(k) === -1) {\n        obj[k] = headers[k];\n      } else {\n        obj[k] = charFill('*', headers[k].length);\n      }\n    }\n  }\n  return obj;\n}\n\n\nfunction scrubRequestParams(params, settings) {\n  var k;\n\n  settings = settings || SETTINGS;\n  for (k in params) {\n    if (params.hasOwnProperty(k) && params[k] && settings.scrubFields.indexOf(k) >= 0) {\n      params[k] = '******';\n    }\n  }\n\n  return params;\n}\n\n\nfunction extractIp(req) {\n  var ip = req.ip;\n  if (!ip) {\n    try {\n      ip = requestIp.getClientIp(req)\n    } catch (error) {\n      // we might get here if req.headers is undefined. in that case go ahead and\n      // walk through the various attributes of req that might contain an address\n      // (request-ip will do this for us but wouldn't have gotten this far if\n      // headers were undefined so we do it manually using the same logic from:\n      // https://github.com/pbojinov/request-ip/blob/master/index.js#L36)\n      if (req.connection && req.connection.remoteAddress) {\n        ip = req.connection.remoteAddress;\n      } else if (req.socket && req.socket.remoteAddress) {\n        ip = req.socket.remoteAddress;\n      } else if (req.connection && req.connection.socket && req.connection.socket.remoteAddress) {\n        ip = req.connection.socket.remoteAddress;\n      } else if (req.info && req.info.remoteAddress) {\n        ip = req.info.remoteAddress;\n      }\n    }\n  }\n  return ip;\n}\n\n\nfunction buildRequestData(req) {\n  var headers, host, proto, reqUrl, parsedUrl, data, bodyParams, k, isPlainObject, hasOwnProperty;\n\n  headers = req.headers || {};\n  host = headers.host || '<no host>';\n  proto = req.protocol || ((req.socket && req.socket.encrypted) ? 'https' : 'http');\n  reqUrl = proto + '://' + host + (req.url || '');\n  parsedUrl = url.parse(reqUrl, true);\n  data = {url: reqUrl,\n    GET: parsedUrl.query,\n    user_ip: extractIp(req),\n    headers: scrubRequestHeaders(headers),\n    method: req.method};\n\n  if (req.body) {\n    bodyParams = {};\n    if (typeof req.body === 'object') {\n      isPlainObject = req.body.constructor === undefined;\n\n      for (k in req.body) {\n        hasOwnProperty = typeof req.body.hasOwnProperty === 'function'\n          && req.body.hasOwnProperty(k);\n\n        if (hasOwnProperty || isPlainObject) {\n          bodyParams[k] = req.body[k];\n        }\n      }\n      data[req.method] = scrubRequestParams(bodyParams);\n    } else {\n      data.body = req.body;\n    }\n  }\n\n  return data;\n}\n\n\nfunction addRequestData(data, req) {\n  var reqData, userId;\n\n  reqData = buildRequestData(req);\n  if (reqData) {\n    data.request = reqData;\n  }\n\n  if (req.route) {\n    data.context = req.route.path;\n  } else {\n    try {\n      data.context = req.app._router.matchRequest(req).path;\n    } catch (ignore) {\n      // ignore\n    }\n  }\n\n  if (req.rollbar_person) {\n    data.person = req.rollbar_person;\n  } else if (req.user) {\n    data.person = {id: req.user.id};\n    if (req.user.username) {\n      data.person.username = req.user.username;\n    }\n    if (req.user.email) {\n      data.person.email = req.user.email;\n    }\n  } else if (req.user_id || req.userId) {\n    userId = req.user_id || req.userId;\n    if (typeof userId === 'function') {\n      userId = userId();\n    }\n    data.person = {id: userId};\n  }\n}\n\n\nfunction buildItemData(item, callback) {\n  var baseData, steps;\n\n  baseData = buildBaseData(item.payload);\n\n  // Add the message to baseData if there is one\n  function addMessageData(callback) {\n    baseData.body = {};\n    if (item.message !== undefined) {\n      baseData.body.message = {\n        body: item.message\n      };\n    }\n    callback(null);\n  }\n\n  // Add the error trace information to baseData if there is one\n  function addTraceData(callback) {\n    if (item.error) {\n      buildErrorData(baseData, item.error, callback);\n    } else {\n      callback(null);\n    }\n  }\n\n  // Add the request information to baseData if there is one\n  function addReqData(callback) {\n    var addReqDataFn = SETTINGS.addRequestData || addRequestData;\n    if (item.request) {\n      addReqDataFn(baseData, item.request);\n    }\n    callback(null);\n  }\n\n  steps = [\n    addMessageData,\n    addTraceData,\n    addReqData\n  ];\n\n  async.series(steps, function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, baseData);\n  });\n\n}\n\n\n// Is the error level of a given item greater than or equal to the configured\n// minimum level?\nfunction levelGteMinimum(item) {\n  var levels, messageLevel, payload, i, length;\n\n  levels = [\n    'critical',\n    'error',\n    'warning',\n    'info',\n    'debug'\n  ];\n  payload = item.payload || {};\n  messageLevel = payload.level === undefined ? 'error' : payload.level;\n\n  for (i = 0, length = levels.length; i < length; i++) {\n    if (levels[i] === messageLevel) {\n      return true;\n    }\n    if (levels[i] === SETTINGS.minimumLevel) {\n      return false;\n    }\n  }\n\n  // At this point the minimum level was never reached and the message level\n  // wasn't a known one; something is wrong\n  logger.error('minimumLevel of \"%s\" is unknown; '\n      + 'meanwhile, message level of \"%s\" is unknown',\n      SETTINGS.minimumLevel, messageLevel);\n\n  // Allow the message to be sent anyway\n  return true;\n}\n\n\nfunction addItem(item, callback) {\n  if (typeof callback !== 'function') {\n    callback = function dummyCallback() { return; };\n  }\n\n  if (!initialized) {\n    var message = 'Rollbar is not initialized';\n    logger.error(message);\n    return callback(new Error(message));\n  }\n\n  if (!SETTINGS.enabled){\n    logger.log('Rollbar is disabled');\n    // reporting is disabled, so it's not an error\n    // let's pretend everything is fine\n    return callback();\n  }\n\n  if (!levelGteMinimum(item)) {\n    logger.log('Item has insufficient level');\n    callback();\n    return;\n  }\n\n  try {\n    var pendingItem = {item:item, req:null};\n    pendingItems.push(pendingItem);\n\n    buildItemData(item, function (err, data) {\n      if (err) {\n        dequeuePendingItem(pendingItem);\n        return callback(err);\n      }\n\n      try {\n        apiClient.postItem(data, function (err, resp) {\n          dequeuePendingItem(pendingItem);\n          callback(err, data, resp);\n        });\n      } catch (e) {\n        dequeuePendingItem(pendingItem);\n        logger.error('Internal error while posting item: ' + e);\n        callback(e);\n      }\n    });\n  } catch (e) {\n    dequeuePendingItem(pendingItem);\n    logger.error('Internal error while building payload: ' + e);\n    callback(e);\n  }\n}\n\n\n/*\n * This will remove a pendingItem entry from the queue.  This should be called\n * either when there is an error, or when the item was sent successfully.\n */\nfunction dequeuePendingItem(pendingItem) {\n  for (var i=0; i < pendingItems.length; i++) {\n    if (pendingItems[i] == pendingItem) {\n      pendingItems.splice(i, 1);\n\n      // If there is a registered wait callback, and we've reached the end\n      // of the pendingItem queue, then call that callback.\n      if (typeof waitCallback === 'function' && exports.pendingItemsCount() === 0) {\n        waitCallback();\n      }\n\n      return;\n    }\n  }\n}\n\n/*\n * Exports for testing\n */\n\n\nexports._scrubRequestHeaders = function (headersToScrub, headers) {\n  return scrubRequestHeaders(headers, headersToScrub ? {scrubHeaders: headersToScrub} : undefined);\n};\n\n\nexports._scrubRequestParams = function (paramsToScrub, params) {\n  return scrubRequestParams(params, paramsToScrub ? {scrubFields: paramsToScrub} : undefined);\n};\n\n\nexports._extractIp = function (req) {\n  return extractIp(req);\n};\n\n\nexports._levelGteMinimum = function (item) {\n  return levelGteMinimum(item);\n};\n\n\n/*\n * Public API\n */\n\nexports.init = function (api, options) {\n  var opt;\n\n  SETTINGS.accessToken = api.accessToken;\n\n  apiClient = api;\n  options = options || {};\n\n  for (opt in options) {\n    if (options.hasOwnProperty(opt)) {\n      SETTINGS[opt] = options[opt];\n    }\n  }\n  initialized = true;\n};\n\n\nexports.pendingItemsCount = function() {\n  return pendingItems.length;\n};\n\n\n/*\n * This registers a wait callback.  This callback will be called\n * when there are 0 pendingItems enqueued.  It could be called immediately\n * if there are none pending right now.  Or if there are pending items\n * then it will be called when the pendingItem queue becomes empty.\n */\nexports.wait = function(callback) {\n  if (exports.pendingItemsCount() === 0) {\n    callback();\n  } else {\n    waitCallback = callback;\n  }\n};\n\n\nexports.handleError = function (err, req, callback) {\n  if (typeof req === 'function') {\n    callback = req;\n    req = null;\n  }\n  if (err instanceof Error) {\n    return exports.handleErrorWithPayloadData(err, {}, req, callback);\n  }\n\n  var stringError;\n  try {\n    stringError = JSON.stringify(err);\n  } catch (e) {\n    stringError = stringify(err);\n  } finally {\n    return exports.reportMessage(stringError, 'error', req, callback);\n  }\n};\n\n\nexports.handleErrorWithPayloadData = function (err, payloadData, req, callback) {\n  // Allow the user to call with an optional request and callback\n  // e.g. handleErrorWithPayloadData(err, payloadData, req, callback)\n  //   or handleErrorWithPayloadData(err, payloadData, callback)\n  //   or handleErrorPayloadData(err, payloadData)\n  if (typeof req === 'function') {\n    callback = req;\n    req = null;\n  }\n\n  if (!(err instanceof Error)) {\n    if (typeof callback === 'function') {\n      return callback(new Error('handleError was passed something other than an Error: ' + err));\n    }\n  }\n  addItem({error: err, payload: payloadData, request: req}, callback);\n};\n\n\nexports.reportMessage = function (message, level, req, callback) {\n  return exports.reportMessageWithPayloadData(message, {level: level}, req, callback);\n};\n\n\nexports.reportMessageWithPayloadData = function (message, payloadData, req, callback) {\n  if (SETTINGS.showReportedMessageTraces) {\n    logger.log(message, new Error().stack);\n  }\n  addItem({message: message, payload: payloadData, request: req}, callback);\n};\n","/home/travis/build/npmtest/node-npmtest-rollbar/node_modules/rollbar/lib/parser.js":"/*jslint devel: true, nomen: true, plusplus: true, regexp: true, indent: 2, maxlen: 100 */\n\n\"use strict\";\n\nvar logger = require('./logger');\nvar async = require('async');\nvar fs = require('fs');\nvar lru = require('lru-cache');\nvar util = require('util');\n\nvar linesOfContext = 3;\nvar tracePattern =\n  /^\\s*at (?:([^(]+(?: \\[\\w\\s+\\])?) )?\\(?(.+?)(?::(\\d+):(\\d+)(?:, <js>:(\\d+):(\\d+))?)?\\)?$/;\n\nvar jadeTracePattern = /^\\s*at .+ \\(.+ (at[^)]+\\))\\)$/;\nvar jadeFramePattern = /^\\s*(>?) [0-9]+\\|(\\s*.+)$/m;\n\n\nvar cache = lru({max: 100});\nvar pendingReads = {};\n\nexports.cache = cache;\nexports.pendingReads = pendingReads;\n\n\n/*\n * Internal\n */\n\n\nfunction getMultipleErrors(errors) {\n  var errArray, key;\n\n  if (errors === null || errors === undefined) {\n    return null;\n  }\n\n  if (typeof errors !== \"object\") {\n    return null;\n  }\n\n  if (util.isArray(errors)) {\n    return errors;\n  }\n\n  errArray = [];\n\n  for (key in errors) {\n    if (errors.hasOwnProperty(key)) {\n      errArray.push(errors[key]);\n    }\n  }\n  return errArray;\n}\n\n\nfunction parseJadeDebugFrame(body) {\n  var lines, lineNumSep, filename, lineno, numLines, msg, i,\n    contextLine, preContext, postContext, line, jadeMatch;\n\n  // Given a Jade exception body, return a frame object\n  lines = body.split('\\n');\n  lineNumSep = lines[0].indexOf(':');\n  filename = lines[0].slice(0, lineNumSep);\n  lineno = parseInt(lines[0].slice(lineNumSep + 1), 10);\n  numLines = lines.length;\n  msg = lines[numLines - 1];\n\n  lines = lines.slice(1, numLines - 1);\n\n  preContext = [];\n  postContext = [];\n  for (i = 0; i < numLines - 2; ++i) {\n    line = lines[i];\n    jadeMatch = line.match(jadeFramePattern);\n    if (jadeMatch) {\n      if (jadeMatch[1] === '>') {\n        contextLine = jadeMatch[2];\n      } else {\n        if (!contextLine) {\n          if (jadeMatch[2]) {\n            preContext.push(jadeMatch[2]);\n          }\n        } else {\n          if (jadeMatch[2]) {\n            postContext.push(jadeMatch[2]);\n          }\n        }\n      }\n    }\n  }\n\n  preContext = preContext.slice(0, Math.min(preContext.length, linesOfContext));\n  postContext = postContext.slice(0, Math.min(postContext.length, linesOfContext));\n\n  return {\n    frame: {\n      method: '<jade>',\n      filename: filename,\n      lineno: lineno,\n      code: contextLine,\n      context: {\n        pre: preContext,\n        post: postContext\n      }\n    },\n    message: msg\n  };\n}\n\n\nfunction extractContextLines(frame, fileLines) {\n  frame.code = fileLines[frame.lineno - 1];\n  frame.context = {\n    pre: fileLines.slice(Math.max(0, frame.lineno - (linesOfContext + 1)), frame.lineno - 1),\n    post: fileLines.slice(frame.lineno, frame.lineno + linesOfContext)\n  };\n}\n\n\nfunction parseFrameLine(line, callback) {\n  var matched, curLine, data, frame;\n\n  curLine = line;\n  matched = curLine.match(jadeTracePattern);\n  if (matched) {\n    curLine = matched[1];\n  }\n  matched = curLine.match(tracePattern);\n  if (!matched) {\n    return callback(null, null);\n  }\n\n  data = matched.slice(1);\n  frame = {\n    method: data[0] || '<unknown>',\n    filename: data[1],\n    lineno: Math.floor(data[2]),\n    colno: Math.floor(data[3])\n  };\n\n  // For coffeescript, lineno and colno refer to the .coffee positions\n  // The .js lineno and colno will be stored in compiled_*\n  if (data[4]) {\n    frame.compiled_lineno = Math.floor(data[4]);\n  }\n\n  if (data[5]) {\n    frame.compiled_colno = Math.floor(data[5]);\n  }\n\n  callback(null, frame);\n}\n\n\nfunction shouldReadFrameFile(frameFilename, callback) {\n  var isValidFilename, isCached, isPending;\n\n  isValidFilename = frameFilename[0] === '/' || frameFilename[0] === '.';\n  isCached = !!cache.get(frameFilename);\n  isPending = !!pendingReads[frameFilename];\n\n  callback(isValidFilename && !isCached && !isPending);\n}\n\n\nfunction readFileLines(filename, callback) {\n  try {\n    fs.readFile(filename, function (err, fileData) {\n      var fileLines;\n      if (err) {\n        return callback(err);\n      }\n\n      fileLines = fileData.toString('utf8').split('\\n');\n      return callback(null, fileLines);\n    });\n  } catch (e) {\n    logger.log(e);\n  }\n}\n\n\n/* Older versions of node do not have fs.exists so we implement our own */\nfunction checkFileExists(filename, callback) {\n  if (fs.exists !== undefined) {\n    fs.exists(filename, callback);\n  } else {\n    fs.stat(filename, function (err) {\n      callback(!err);\n    });\n  }\n}\n\n\nfunction gatherContexts(frames, callback) {\n  var frameFilenames = [];\n\n  frames.forEach(function (frame) {\n    if (frameFilenames.indexOf(frame.filename) === -1) {\n      frameFilenames.push(frame.filename);\n    }\n  });\n\n  async.filter(frameFilenames, shouldReadFrameFile, function (results) {\n    var tempFileCache;\n\n    tempFileCache = {};\n\n    function gatherFileData(filename, callback) {\n      readFileLines(filename, function (err, lines) {\n        if (err) {\n          return callback(err);\n        }\n\n        // Cache this in a temp cache as well as the LRU cache so that\n        // we know we will have all of the necessary file contents for\n        // each filename in tempFileCache.\n        tempFileCache[filename] = lines;\n        cache.set(filename, lines);\n\n        return callback(null);\n      });\n    }\n\n    function gatherContextLines(frame, callback) {\n      var lines = tempFileCache[frame.filename] || cache.get(frame.filename);\n\n      if (lines) {\n        extractContextLines(frame, lines);\n      }\n      callback(null);\n    }\n\n    async.filter(results, checkFileExists, function (filenames) {\n      async.each(filenames, gatherFileData, function (err) {\n        if (err) {\n          return callback(err);\n        }\n        async.eachSeries(frames, gatherContextLines, function (err) {\n          if (err) {\n            return callback(err);\n          }\n          callback(null, frames);\n        });\n      });\n    });\n\n  });\n}\n\n/*\n * Public API\n */\n\n\nexports.parseException = function (exc, callback) {\n  var multipleErrs = getMultipleErrors(exc.errors);\n\n  return exports.parseStack(exc.stack, function (err, stack) {\n    var message, clss, ret, firstErr, jadeMatch, jadeData;\n\n    if (err) {\n      logger.error('could not parse exception, err: ' + err);\n      return callback(err);\n    }\n    message = String(exc.message || '<no message>') ;\n    clss = String(exc.name || '<unknown>');\n\n    ret = {\n      class: clss,\n      message: message,\n      frames: stack\n    };\n\n    if (multipleErrs && multipleErrs.length) {\n      firstErr = multipleErrs[0];\n      ret = {\n        class: clss,\n        message: String(firstErr.message || '<no message>'),\n        frames: stack\n      };\n    }\n\n    jadeMatch = message.match(jadeFramePattern);\n    if (jadeMatch) {\n      jadeData = parseJadeDebugFrame(message);\n      ret.message = jadeData.message;\n      ret.frames.push(jadeData.frame);\n    }\n    return callback(null, ret);\n  });\n};\n\n\nexports.parseStack = function (stack, callback) {\n  var lines, _stack = stack;\n\n  // Some JS frameworks (e.g. Meteor) might bury the stack property\n  while (typeof _stack === 'object') {\n    _stack = _stack && _stack.stack;\n  }\n\n  // grab all lines except the first\n  lines = (_stack || '').split('\\n').slice(1);\n\n  // Parse out all of the frame and filename info\n  async.map(lines, parseFrameLine, function (err, frames) {\n    if (err) {\n      return callback(err);\n    }\n    frames.reverse();\n    async.filter(frames, function (frame, callback) { callback(!!frame); }, function (results) {\n      gatherContexts(results, callback);\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-rollbar/node_modules/rollbar/lib/error.js":"var util = require('util');\n\n\nfunction RollbarError(message, nested)\n{\n  Error.call(this);\n  Error.captureStackTrace(this, this.constructor);\n\n  this.message = message;\n  this.nested = nested;\n  this.name = this.constructor.name;\n}\n\nutil.inherits(RollbarError, Error);\n\nmodule.exports = RollbarError;\n\n","/home/travis/build/npmtest/node-npmtest-rollbar/node_modules/rollbar/deploy.js":"/*jslint devel: true, nomen: true, indent: 2, maxlen: 100 */\n\n\"use strict\";\n\nvar deploy = require('./lib/deploy');\n\nexports.createDeploy = deploy.createDeploy;\nexports.getDeploy = deploy.getDeploy;\nexports.listDeploys = deploy.listDeploys;\n","/home/travis/build/npmtest/node-npmtest-rollbar/node_modules/rollbar/lib/deploy.js":"/*jslint devel: true, nomen: true, plusplus: true, regexp: true, indent: 2, maxlen: 100 */\n\n/*\n *  This is an implementation of Rollbar's deploy feature.  It can be used and\n *  required independently from the rest of the Rollbar library.  Implementation\n *  details can be found at: https://rollbar.com/docs/api/deploys/\n */\n\n\"use strict\";\n\nvar https = require('https');\nvar logger = require('./logger');\n\nfunction handleResponse(res, callback) {\n  res.setEncoding('utf8');\n  var rawData = '';\n  res.on('data', function(chunk){ rawData += chunk });\n  res.on('end', function() {\n    try {\n      var parsedData = JSON.parse(rawData);\n      if (parsedData.err) {\n        logger.error(parsedData.message);\n      }\n      callback(parsedData);\n    } catch (e) {\n      logger.error(e);\n    }\n  });\n};\n\nfunction createRequestOpts(method, path, accessToken, postData) {\n  var requestOpts = {\n    protocol: 'https:',\n    host: 'api.rollbar.com',\n    port: 443,\n    path: '/api/1/'+path,\n    method: method,\n    headers: {\n      'Content-Type': 'application/json',\n      'X-Rollbar-Access-Token': accessToken\n    }\n  };\n\n  if (postData) {\n    requestOpts.headers['Content-Length'] = Buffer.byteLength(postData);\n  }\n\n  return requestOpts;\n};\n\n/**\n * Create a deploy entry.\n * This is an implementation of the API specified at:\n * https://rollbar.com/docs/api/deploys/#record-create-a-deploy\n *\n * @param accessToken - A post_server_item-scope project access token.\n * @param params - An object with some required and optional parameters\n *          environment:  Required. Name of the environment being deployed. (String up to 255 chars)\n *          revision: Required. String identifying the revision being deployed, such as a Git SHA. (String up to 255 chars). This param can also be provided under the name head_long.\n *          rollbar_username: Rollbar username of the user who deployed.\n *          local_username: Username (on your system) who deployed. (String up to 255 chars)\n *          comment: Additional text data to record with this deploy. (String up to 64kb)\n * @param opts - An object with connection options.\n * @param callback\n */\nexports.createDeploy = function(accessToken, params, opts, callback) {\n  if (typeof callback != 'function')\n    callback = function(){};\n\n  var requestOpts = createRequestOpts('POST', 'deploy/', accessToken);\n\n  var req = https.request(requestOpts, function(res) {\n    handleResponse(res, callback);\n  });\n\n  var writeData = {};\n  try {\n    try {\n      writeData = JSON.stringify(params);\n    } catch (e) {\n      writedata = stringify(params);\n    }\n  } catch (e) {\n    logger.error('Could not safe-stringify data.  Giving up');\n    return callback(e);\n  }\n  req.write(writeData);\n  req.end();\n};\n\n/**\n * Retrieve a single deploy entry using an ID.\n * This is an implementation of the API specified at:\n * https://rollbar.com/docs/api/deploys/#get-a-deploy-by-id\n *\n * @param accessToken - Required. A read-scope project access token.\n * @param deployId - Required.  The ID to fetch.\n * @param opts - An object with connection options\n * @param callback\n */\nexports.getDeploy = function(accessToken, deployId, opts, callback) {\n  if (typeof callback != 'function')\n    callback = function(){};\n\n  var params = [];\n  params.push('access_token='+accessToken);\n  var paramsStr = params.join('&');\n\n  var requestOpts = createRequestOpts('GET', 'deploy/'+deployId+'/?'+paramsStr, accessToken);\n\n  var req = https.request(requestOpts, function(res) {\n    handleResponse(res, callback);\n  });\n\n  req.end();\n};\n\n/**\n * Retrieve a list of deploys.\n * This is an implementation of the API specified at:\n * https://rollbar.com/docs/api/deploys/#list-all-deploys\n *\n * @param accessToken - Required. A read-scope project access token.\n * @param pageNum - An integer page number >= 1.  If not specified, 1 will be used.\n * @param opts - An object with connection options.\n * @param callback\n */\nexports.listDeploys = function(accessToken, pageNum, opts, callback) {\n  if (typeof pageNum != 'number' || pageNum < 1)\n    pageNum = 1;\n\n  if (typeof callback != 'function')\n    callback = function(){};\n\n  var params = [];\n  params.push('page='+pageNum);\n  params.push('access_token='+accessToken);\n  var paramsStr = params.join('&');\n\n  \n  var requestOpts = createRequestOpts('GET', 'deploys?'+paramsStr, accessToken);\n\n  var req = https.request(requestOpts, function(res) {\n    handleResponse(res, callback);\n  });\n\n  req.end();\n};\n"}